#include "codegen/x64_codegen.hpp"

#include <fmt/format.h>

#include <algorithm>
#include <cassert>
#include <cstring>

namespace golangc {
namespace codegen {

// ============================================================================
// Register names
// ============================================================================

std::string_view reg_name(X64Reg reg, RegSize size) {
    // QWord names (default)
    static constexpr const char* qword_names[] = {
        "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
        "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    };
    static constexpr const char* dword_names[] = {
        "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
        "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d",
    };
    static constexpr const char* word_names[] = {
        "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
        "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w",
    };
    static constexpr const char* byte_names[] = {
        "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil",
        "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b",
    };

    auto idx = static_cast<uint8_t>(reg);

    // XMM registers
    if (idx >= static_cast<uint8_t>(X64Reg::XMM0)) {
        auto xmm_idx = idx - static_cast<uint8_t>(X64Reg::XMM0);
        static const std::string xmm_names[] = {
            "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7",
            "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15",
        };
        return xmm_names[xmm_idx];
    }

    switch (size) {
        case RegSize::QWord: return qword_names[idx];
        case RegSize::DWord: return dword_names[idx];
        case RegSize::Word:  return word_names[idx];
        case RegSize::Byte:  return byte_names[idx];
    }
    return qword_names[idx];
}

// ============================================================================
// FrameLayout
// ============================================================================

int32_t FrameLayout::allocate(uint32_t value_id, int32_t size, int32_t alignment) {
    // Align the offset
    current_offset_ += size;
    if (current_offset_ % alignment != 0) {
        current_offset_ += alignment - (current_offset_ % alignment);
    }
    int32_t offset = -current_offset_;
    slots_[value_id] = {offset, size};
    return offset;
}

int32_t FrameLayout::offset_of(uint32_t value_id) const {
    auto it = slots_.find(value_id);
    assert(it != slots_.end() && "Value not found in frame layout");
    return it->second.offset;
}

bool FrameLayout::has_slot(uint32_t value_id) const {
    return slots_.find(value_id) != slots_.end();
}

int32_t FrameLayout::frame_size() const {
    // Align to 16 bytes
    int32_t raw = -current_offset_; // current_offset_ is negative conceptually
    if (raw < 0) raw = -raw;
    raw = current_offset_; // positive size
    if (raw == 0) return 0;
    return (raw + 15) & ~15;
}

void FrameLayout::reset() {
    slots_.clear();
    current_offset_ = 0;
}

// ============================================================================
// X64CodeGenerator â€” Module generation
// ============================================================================

std::string X64CodeGenerator::generate(const ir::Module& module) {
    out_.clear();
    string_pool_.clear();
    string_counter_ = 0;
    float_pool_.clear();
    float_counter_ = 0;
    needs_sign_mask_ = false;

    emit_module_header(module);

    // Generate all functions
    for (const auto& func : module.functions) {
        emit_function(*func);
    }

    // Emit data section with string literals
    emit_data_section();

    emit_module_footer();

    return out_;
}

std::string X64CodeGenerator::generate_function(const ir::Function& func) {
    out_.clear();
    string_pool_.clear();
    string_counter_ = 0;
    float_pool_.clear();
    float_counter_ = 0;
    needs_sign_mask_ = false;

    emit_function(func);

    return out_;
}

void X64CodeGenerator::emit_module_header(const ir::Module& module) {
    emit_comment(fmt::format("Generated by golangc 0.6.0 - module \"{}\"", module.name));
    emit_blank();

    // Declare external runtime functions
    out_ += "EXTERN golangc_println_int:PROC\n";
    out_ += "EXTERN golangc_println_string:PROC\n";
    out_ += "EXTERN golangc_println_bool:PROC\n";
    out_ += "EXTERN golangc_print_int:PROC\n";
    out_ += "EXTERN golangc_print_string:PROC\n";
    out_ += "EXTERN golangc_print_bool:PROC\n";
    out_ += "EXTERN golangc_print_space:PROC\n";
    out_ += "EXTERN golangc_print_newline:PROC\n";
    out_ += "EXTERN golangc_panic:PROC\n";
    out_ += "EXTERN golangc_println_float:PROC\n";
    out_ += "EXTERN golangc_print_float:PROC\n";
    out_ += "EXTERN golangc_string_concat:PROC\n";
    out_ += "EXTERN golangc_string_eq:PROC\n";
    out_ += "EXTERN golangc_select:PROC\n";
    out_ += "EXTERN golangc_chan_make:PROC\n";
    out_ += "EXTERN golangc_chan_send:PROC\n";
    out_ += "EXTERN golangc_chan_recv:PROC\n";
    out_ += "EXTERN golangc_go_spawn:PROC\n";
    out_ += "EXTERN golangc_map_make:PROC\n";
    out_ += "EXTERN golangc_map_get:PROC\n";
    out_ += "EXTERN golangc_map_set:PROC\n";
    out_ += "EXTERN golangc_map_len:PROC\n";
    out_ += "EXTERN golangc_map_delete:PROC\n";
    out_ += "EXTERN golangc_map_iter_make:PROC\n";
    out_ += "EXTERN golangc_map_iter_next:PROC\n";
    out_ += "EXTERN golangc_map_iter_free:PROC\n";
    out_ += "EXTERN golangc_slice_append:PROC\n";
    out_ += "EXTERN malloc:PROC\n";
    out_ += "EXTERN golangc_closure_env:QWORD\n";
    emit_blank();
}

void X64CodeGenerator::emit_data_section() {
    if (string_pool_.empty() && float_pool_.empty() && !needs_sign_mask_) return;

    emit_blank();
    out_ += "_DATA SEGMENT\n";

    // Emit string literals
    for (const auto& str : string_pool_) {
        out_ += fmt::format("{} DB ", str.label);
        for (size_t i = 0; i < str.data.size(); ++i) {
            if (i > 0) out_ += ", ";
            out_ += fmt::format("{}", static_cast<int>(static_cast<unsigned char>(str.data[i])));
        }
        if (str.data.empty()) {
            out_ += "0"; // null byte for empty strings
        } else {
            out_ += ", 0"; // null terminator
        }
        out_ += "\n";
    }

    // Emit float literals as raw 64-bit hex (avoids MASM precision issues)
    for (const auto& flt : float_pool_) {
        uint64_t bits = 0;
        std::memcpy(&bits, &flt.value, sizeof(double));
        out_ += fmt::format("ALIGN 8\n{} DQ {:016X}h\n", flt.label, bits);
    }

    // Emit sign mask for float negation
    if (needs_sign_mask_) {
        out_ += "ALIGN 8\n__f64_sign_mask DQ 8000000000000000h\n";
    }

    out_ += "_DATA ENDS\n";
}

void X64CodeGenerator::emit_module_footer() {
    emit_blank();
    out_ += "END\n";
}

// ============================================================================
// Function generation
// ============================================================================

void X64CodeGenerator::emit_function(const ir::Function& func) {
    frame_.reset();
    temp_slots_.clear();
    defers_.clear();
    closure_env_slots_.clear();
    current_func_ = &func;
    has_sret_ = false;
    sret_slot_ = 0;

    // Detect sret: function returns a large struct (>8 bytes)
    if (func.return_type && is_large_struct(func.return_type)) {
        has_sret_ = true;
    }

    // First pass: scan allocas and assign stack offsets
    scan_allocas(func);

    // Second pass: pre-allocate temp slots for ALL value-producing instructions
    // so the frame size is known before emitting the prologue.
    prescan_temps(func);

    auto name = masm_name(func.name);

    out_ += "_TEXT SEGMENT\n";
    out_ += fmt::format("{} PROC\n", name);

    emit_prologue(func);

    // Emit basic blocks
    for (size_t i = 0; i < func.blocks.size(); ++i) {
        emit_block(*func.blocks[i], func);
    }

    out_ += fmt::format("{} ENDP\n", name);
    out_ += "_TEXT ENDS\n";
    emit_blank();
    current_func_ = nullptr;
}

void X64CodeGenerator::emit_prologue(const ir::Function& func) {
    emit("push rbp");
    emit("mov rbp, rsp");

    int32_t fsize = frame_.frame_size();
    // Ensure enough space for shadow space on any calls + frame
    // Minimum 32 bytes for shadow space even if no locals
    if (fsize < kShadowSpace) fsize = kShadowSpace;
    // Align to 16 bytes (account for pushed rbp)
    if (fsize % 16 != 0) fsize = (fsize + 15) & ~15;

    emit(fmt::format("sub rsp, {}", fsize));

    // If sret, save the sret pointer (passed in RCX) to a hidden slot
    // The actual params shift by 1 register position
    size_t reg_offset = 0;
    if (has_sret_) {
        emit(fmt::format("mov QWORD PTR [rbp{}], rcx", sret_slot_));
        reg_offset = 1;
    }

    // Save parameters from registers to stack slots
    // Windows x64: float params use XMM registers at positional slots
    static constexpr X64Reg kXmmArgs[] = {X64Reg::XMM0, X64Reg::XMM1, X64Reg::XMM2, X64Reg::XMM3};

    for (size_t i = 0; i < func.params.size() && (i + reg_offset) < kMaxRegArgs; ++i) {
        auto param_id = func.params[i]->id;
        if (frame_.has_slot(param_id)) {
            auto* param_type = func.params[i]->type;

            // For large struct params passed by pointer: copy from pointer into local alloca
            if (param_type && is_large_struct(param_type)) {
                auto reg = kArgRegs[i + reg_offset];
                int32_t nq = type_qwords(param_type);
                auto param_off = frame_.offset_of(param_id);
                emit(fmt::format("mov rcx, {}", reg_name(reg)));
                for (int32_t q = 0; q < nq; ++q) {
                    emit(fmt::format("mov rax, QWORD PTR [rcx+{}]", q * 8));
                    emit(fmt::format("mov QWORD PTR [rbp{}], rax", param_off + q * 8));
                }
            } else if (param_type && is_float_type(param_type)) {
                // Float params come in XMM registers
                auto xmm = kXmmArgs[i + reg_offset];
                emit(fmt::format("movsd {}, {}",
                                 stack_operand(param_id),
                                 reg_name(xmm)));
            } else {
                auto reg = kArgRegs[i + reg_offset];
                emit(fmt::format("mov {}, {}",
                                 stack_operand(param_id),
                                 reg_name(reg)));
            }
        }
    }
}

void X64CodeGenerator::emit_epilogue() {
    int32_t fsize = frame_.frame_size();
    if (fsize < kShadowSpace) fsize = kShadowSpace;
    if (fsize % 16 != 0) fsize = (fsize + 15) & ~15;

    emit(fmt::format("add rsp, {}", fsize));
    emit("pop rbp");
    emit("ret");
}

void X64CodeGenerator::scan_allocas(const ir::Function& func) {
    // If sret, allocate a hidden slot for the sret pointer
    if (has_sret_) {
        // Use a unique ID that won't collide with real values
        uint32_t sret_id = 200000;
        frame_.allocate(sret_id, 8);
        sret_slot_ = frame_.offset_of(sret_id);
    }

    // Allocate slots for all parameters with correct sizes
    for (const auto& param : func.params) {
        int32_t sz = 8;
        if (param->type) {
            sz = type_size(param->type);
            if (sz < 8) sz = 8;
        }
        frame_.allocate(param->id, sz);
    }

    // Then scan all allocas in all blocks
    for (const auto& block : func.blocks) {
        for (const auto& inst : block->instructions) {
            if (inst->opcode == ir::Opcode::Alloca) {
                // Use alloc_type for sizing (the actual type being allocated)
                int32_t size = 8;
                if (inst->alloc_type) {
                    size = type_size(inst->alloc_type);
                }
                if (size < 8) size = 8; // Minimum 8 bytes
                frame_.allocate(inst->id, size);
            }
        }
    }
}

void X64CodeGenerator::prescan_temps(const ir::Function& func) {
    // If the function contains any DeferCall, pre-allocate the ret-stash slot
    // (used to preserve the return value across deferred calls at ret sites).
    bool has_defer = false;
    for (const auto& block : func.blocks) {
        for (const auto& inst : block->instructions) {
            if (inst->opcode == ir::Opcode::DeferCall) { has_defer = true; break; }
        }
        if (has_defer) break;
    }
    if (has_defer) {
        constexpr uint32_t ret_stash_id = 400000;
        if (temp_slots_.find(ret_stash_id) == temp_slots_.end() &&
            !frame_.has_slot(ret_stash_id)) {
            int32_t off = frame_.allocate(ret_stash_id, 8);
            temp_slots_[ret_stash_id] = off;
        }
    }

    // Pre-allocate temp stack slots for every value-producing instruction
    // so the frame size is fully known before the prologue is emitted.
    for (const auto& block : func.blocks) {
        for (const auto& inst : block->instructions) {
            // Skip allocas (already handled) and non-value instructions
            if (inst->opcode == ir::Opcode::Alloca) continue;

            // Check if this instruction produces a value that needs a temp slot
            bool produces_value = true;
            switch (inst->opcode) {
                case ir::Opcode::Store:
                case ir::Opcode::Br:
                case ir::Opcode::CondBr:
                case ir::Opcode::Ret:
                case ir::Opcode::Switch:
                case ir::Opcode::ChanSend:
                case ir::Opcode::MapSet:
                case ir::Opcode::MapDelete:
                case ir::Opcode::MapIterFree:
                case ir::Opcode::GoSpawn:
                case ir::Opcode::DeferCall:
                case ir::Opcode::Panic:
                case ir::Opcode::Println:
                    produces_value = false;
                    break;
                default:
                    break;
            }

            if (produces_value && !frame_.has_slot(inst->id)) {
                // Allocate correct size for struct-typed results
                int32_t sz = 8;
                if (inst->type && inst->type->is_struct()) {
                    sz = type_size(inst->type);
                    if (sz < 8) sz = 8;
                }
                int32_t offset = frame_.allocate(inst->id, sz);
                temp_slots_[inst->id] = offset;

                // For struct types, create alias slots for extra QWORDs
                // that point into the contiguous block at ascending offsets.
                if (inst->type && inst->type->is_struct()) {
                    int32_t nq = type_qwords(inst->type);
                    for (int32_t q = 1; q < nq; ++q) {
                        uint32_t extra_id = inst->id + static_cast<uint32_t>(q) * 100000;
                        // Alias into the contiguous block: base + q*8
                        temp_slots_[extra_id] = offset + q * 8;
                    }
                }
            }

            // ConstString needs an extra slot for the length
            // (ConstString type is string = {ptr, i64}, already handled above
            //  as struct, but ensure the len_id alias exists)
            if (inst->opcode == ir::Opcode::ConstString) {
                uint32_t len_id = inst->id + 100000;
                if (temp_slots_.find(len_id) == temp_slots_.end()) {
                    // If the main slot was allocated as a 16-byte struct, alias into it
                    if (temp_slots_.count(inst->id)) {
                        temp_slots_[len_id] = temp_slots_[inst->id] + 8;
                    } else {
                        frame_.allocate(len_id, 8);
                        temp_slots_[len_id] = frame_.offset_of(len_id);
                    }
                }
            }

            // InterfaceMake produces a 2-QWORD value (type is {ptr, ptr})
            // Already handled by the struct alias logic above, but ensure it works
            // for the case where interface_type() might not be detected as struct.
            if (inst->opcode == ir::Opcode::InterfaceMake) {
                uint32_t extra_id = inst->id + 100000;
                if (temp_slots_.find(extra_id) == temp_slots_.end()) {
                    if (temp_slots_.count(inst->id)) {
                        temp_slots_[extra_id] = temp_slots_[inst->id] + 8;
                    } else {
                        frame_.allocate(extra_id, 8);
                        temp_slots_[extra_id] = frame_.offset_of(extra_id);
                    }
                }
            }

            // MapGet needs a hidden ok-slot (id + 300000) pre-allocated in the frame
            if (inst->opcode == ir::Opcode::MapGet) {
                uint32_t ok_id = inst->id + 300000;
                if (temp_slots_.find(ok_id) == temp_slots_.end()) {
                    int32_t ok_off = frame_.allocate(ok_id, 8);
                    temp_slots_[ok_id] = ok_off;
                }
            }

            // Note: ClosureMake uses {ptr, ptr} struct type, so the prescan struct
            // aliasing logic above (q=1 alias at id+100000) handles the env slot.
        }
    }
}

// ============================================================================
// Block generation
// ============================================================================

void X64CodeGenerator::emit_block(const ir::BasicBlock& block, const ir::Function& func) {
    // Don't emit label for entry block if it's the first block
    bool is_entry = (&block == func.blocks.front().get());
    if (!is_entry) {
        emit_label(block_label(func, block.label));
    }

    for (const auto& inst : block.instructions) {
        emit_instruction(*inst, func);
    }
}

// ============================================================================
// Helpers
// ============================================================================

void X64CodeGenerator::emit(std::string_view line) {
    out_ += "    ";
    out_ += line;
    out_ += "\n";
}

void X64CodeGenerator::emit_label(std::string_view label) {
    out_ += label;
    out_ += ":\n";
}

void X64CodeGenerator::emit_comment(std::string_view comment) {
    out_ += "; ";
    out_ += comment;
    out_ += "\n";
}

void X64CodeGenerator::emit_blank() {
    out_ += "\n";
}

int32_t X64CodeGenerator::get_temp_slot(uint32_t value_id) {
    auto it = temp_slots_.find(value_id);
    if (it != temp_slots_.end()) return it->second;

    int32_t offset = frame_.allocate(value_id, 8);
    temp_slots_[value_id] = offset;
    return offset;
}

void X64CodeGenerator::load_value_to_rax(const ir::Value* val) {
    load_value_to_reg(val, X64Reg::RAX);
}

void X64CodeGenerator::load_value_to_reg(const ir::Value* val, X64Reg reg) {
    if (!val) return;

    auto r = reg_name(reg);

    // Check if it's a constant instruction that we can inline
    auto* inst = dynamic_cast<const ir::Instruction*>(val);
    if (inst) {
        switch (inst->opcode) {
            case ir::Opcode::ConstInt:
                emit(fmt::format("mov {}, {}", r, inst->imm_int));
                return;
            case ir::Opcode::ConstBool:
                emit(fmt::format("mov {}, {}", r, inst->imm_int ? 1 : 0));
                return;
            default:
                break;
        }
    }

    // Check if it's a function (for call targets)
    auto* func = dynamic_cast<const ir::Function*>(val);
    if (func) {
        emit(fmt::format("lea {}, [{}]", r, masm_name(func->name)));
        return;
    }

    // Otherwise load from stack
    if (frame_.has_slot(val->id)) {
        emit(fmt::format("mov {}, QWORD PTR [rbp{}]", r, frame_.offset_of(val->id)));
    } else if (temp_slots_.count(val->id)) {
        emit(fmt::format("mov {}, QWORD PTR [rbp{}]", r, temp_slots_[val->id]));
    }
}

void X64CodeGenerator::load_value_to_xmm(const ir::Value* val, X64Reg xmm_reg) {
    if (!val) return;
    auto xmm = reg_name(xmm_reg);

    // Load from stack slot via movsd
    if (frame_.has_slot(val->id)) {
        emit(fmt::format("movsd {}, QWORD PTR [rbp{}]", xmm, frame_.offset_of(val->id)));
    } else if (temp_slots_.count(val->id)) {
        emit(fmt::format("movsd {}, QWORD PTR [rbp{}]", xmm, temp_slots_[val->id]));
    }
}

std::string X64CodeGenerator::stack_operand(uint32_t value_id) const {
    if (frame_.has_slot(value_id)) {
        return fmt::format("QWORD PTR [rbp{}]", frame_.offset_of(value_id));
    }
    auto it = temp_slots_.find(value_id);
    if (it != temp_slots_.end()) {
        return fmt::format("QWORD PTR [rbp{}]", it->second);
    }
    return fmt::format("QWORD PTR [rbp-???{}]", value_id);
}

std::string X64CodeGenerator::masm_name(std::string_view ir_name) {
    std::string result(ir_name);
    for (auto& c : result) {
        if (c == '.') c = '$';
    }
    return result;
}

std::string X64CodeGenerator::block_label(const ir::Function& func,
                                           std::string_view block_name) {
    return fmt::format("{}${}", masm_name(func.name), masm_name(block_name));
}

int32_t X64CodeGenerator::type_size(const ir::IRType* type) {
    if (!type) return 8;
    switch (type->kind) {
        case ir::IRTypeKind::Void: return 0;
        case ir::IRTypeKind::I1:   return 1;
        case ir::IRTypeKind::I8:   return 1;
        case ir::IRTypeKind::I16:  return 2;
        case ir::IRTypeKind::I32:  return 4;
        case ir::IRTypeKind::I64:  return 8;
        case ir::IRTypeKind::F32:  return 4;
        case ir::IRTypeKind::F64:  return 8;
        case ir::IRTypeKind::Ptr:  return 8;
        case ir::IRTypeKind::Struct: {
            int32_t total = 0;
            for (auto* f : type->fields) {
                total += type_size(f);
                // Align each field to its natural alignment (simplified: 8-byte)
                if (total % 8 != 0) total = (total + 7) & ~7;
            }
            return total > 0 ? total : 8;
        }
        case ir::IRTypeKind::Array:
            return type_size(type->element) * static_cast<int32_t>(type->count);
        case ir::IRTypeKind::Func:
            return 8; // Function pointer
    }
    return 8;
}

bool X64CodeGenerator::is_string_type(const ir::IRType* type) {
    if (!type || type->kind != ir::IRTypeKind::Struct) return false;
    return type->fields.size() == 2 &&
           type->fields[0]->kind == ir::IRTypeKind::Ptr &&
           type->fields[1]->kind == ir::IRTypeKind::I64;
}

int32_t X64CodeGenerator::type_qwords(const ir::IRType* type) {
    int32_t sz = type_size(type);
    return (sz + 7) / 8;
}

bool X64CodeGenerator::is_large_struct(const ir::IRType* type) {
    if (!type || type->kind != ir::IRTypeKind::Struct) return false;
    return type_size(type) > 8;
}

bool X64CodeGenerator::is_float_type(const ir::IRType* type) {
    if (!type) return false;
    return type->kind == ir::IRTypeKind::F32 || type->kind == ir::IRTypeKind::F64;
}

bool X64CodeGenerator::is_slice_type(const ir::IRType* type) {
    if (!type || type->kind != ir::IRTypeKind::Struct) return false;
    return type->fields.size() == 3 &&
           type->fields[0]->kind == ir::IRTypeKind::Ptr &&
           type->fields[1]->kind == ir::IRTypeKind::I64 &&
           type->fields[2]->kind == ir::IRTypeKind::I64;
}

bool X64CodeGenerator::is_getptr(const ir::Value* val) {
    auto* inst = dynamic_cast<const ir::Instruction*>(val);
    return inst && (inst->opcode == ir::Opcode::GetPtr ||
                    inst->opcode == ir::Opcode::SliceIndexAddr);
}

void X64CodeGenerator::emit_struct_copy(int32_t dst_offset, int32_t src_offset,
                                         int32_t num_qwords) {
    for (int32_t q = 0; q < num_qwords; ++q) {
        emit(fmt::format("mov rax, QWORD PTR [rbp{}]", src_offset + q * 8));
        emit(fmt::format("mov QWORD PTR [rbp{}], rax", dst_offset + q * 8));
    }
}

} // namespace codegen
} // namespace golangc
