#include "codegen/x64_codegen.hpp"

#include <fmt/format.h>

#include <algorithm>
#include <cassert>

namespace golangc {
namespace codegen {

// ============================================================================
// Register names
// ============================================================================

std::string_view reg_name(X64Reg reg, RegSize size) {
    // QWord names (default)
    static constexpr const char* qword_names[] = {
        "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
        "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    };
    static constexpr const char* dword_names[] = {
        "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
        "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d",
    };
    static constexpr const char* word_names[] = {
        "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
        "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w",
    };
    static constexpr const char* byte_names[] = {
        "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil",
        "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b",
    };

    auto idx = static_cast<uint8_t>(reg);

    // XMM registers
    if (idx >= static_cast<uint8_t>(X64Reg::XMM0)) {
        auto xmm_idx = idx - static_cast<uint8_t>(X64Reg::XMM0);
        static const std::string xmm_names[] = {
            "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7",
            "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15",
        };
        return xmm_names[xmm_idx];
    }

    switch (size) {
        case RegSize::QWord: return qword_names[idx];
        case RegSize::DWord: return dword_names[idx];
        case RegSize::Word:  return word_names[idx];
        case RegSize::Byte:  return byte_names[idx];
    }
    return qword_names[idx];
}

// ============================================================================
// FrameLayout
// ============================================================================

int32_t FrameLayout::allocate(uint32_t value_id, int32_t size, int32_t alignment) {
    // Align the offset
    current_offset_ += size;
    if (current_offset_ % alignment != 0) {
        current_offset_ += alignment - (current_offset_ % alignment);
    }
    int32_t offset = -current_offset_;
    slots_[value_id] = {offset, size};
    return offset;
}

int32_t FrameLayout::offset_of(uint32_t value_id) const {
    auto it = slots_.find(value_id);
    assert(it != slots_.end() && "Value not found in frame layout");
    return it->second.offset;
}

bool FrameLayout::has_slot(uint32_t value_id) const {
    return slots_.find(value_id) != slots_.end();
}

int32_t FrameLayout::frame_size() const {
    // Align to 16 bytes
    int32_t raw = -current_offset_; // current_offset_ is negative conceptually
    if (raw < 0) raw = -raw;
    raw = current_offset_; // positive size
    if (raw == 0) return 0;
    return (raw + 15) & ~15;
}

void FrameLayout::reset() {
    slots_.clear();
    current_offset_ = 0;
}

// ============================================================================
// X64CodeGenerator â€” Module generation
// ============================================================================

std::string X64CodeGenerator::generate(const ir::Module& module) {
    out_.clear();
    string_pool_.clear();
    string_counter_ = 0;

    emit_module_header(module);

    // Generate all functions
    for (const auto& func : module.functions) {
        emit_function(*func);
    }

    // Emit data section with string literals
    emit_data_section();

    emit_module_footer();

    return out_;
}

std::string X64CodeGenerator::generate_function(const ir::Function& func) {
    out_.clear();
    string_pool_.clear();
    string_counter_ = 0;

    emit_function(func);

    return out_;
}

void X64CodeGenerator::emit_module_header(const ir::Module& module) {
    emit_comment(fmt::format("Generated by golangc 0.5.0 - module \"{}\"", module.name));
    emit_blank();

    // Declare external runtime functions
    out_ += "EXTERN golangc_println_int:PROC\n";
    out_ += "EXTERN golangc_println_string:PROC\n";
    out_ += "EXTERN golangc_println_bool:PROC\n";
    out_ += "EXTERN golangc_panic:PROC\n";
    emit_blank();
}

void X64CodeGenerator::emit_data_section() {
    if (string_pool_.empty()) return;

    emit_blank();
    out_ += "_DATA SEGMENT\n";
    for (const auto& str : string_pool_) {
        // Emit string bytes as DB directive
        out_ += fmt::format("{} DB ", str.label);
        for (size_t i = 0; i < str.data.size(); ++i) {
            if (i > 0) out_ += ", ";
            out_ += fmt::format("{}", static_cast<int>(static_cast<unsigned char>(str.data[i])));
        }
        if (str.data.empty()) {
            out_ += "0"; // null byte for empty strings
        } else {
            out_ += ", 0"; // null terminator
        }
        out_ += "\n";
    }
    out_ += "_DATA ENDS\n";
}

void X64CodeGenerator::emit_module_footer() {
    emit_blank();
    out_ += "END\n";
}

// ============================================================================
// Function generation
// ============================================================================

void X64CodeGenerator::emit_function(const ir::Function& func) {
    frame_.reset();
    temp_slots_.clear();

    // First pass: scan allocas and assign stack offsets
    scan_allocas(func);

    // Second pass: pre-allocate temp slots for ALL value-producing instructions
    // so the frame size is known before emitting the prologue.
    prescan_temps(func);

    auto name = masm_name(func.name);

    out_ += "_TEXT SEGMENT\n";
    out_ += fmt::format("{} PROC\n", name);

    emit_prologue(func);

    // Emit basic blocks
    for (size_t i = 0; i < func.blocks.size(); ++i) {
        emit_block(*func.blocks[i], func);
    }

    out_ += fmt::format("{} ENDP\n", name);
    out_ += "_TEXT ENDS\n";
    emit_blank();
}

void X64CodeGenerator::emit_prologue(const ir::Function& func) {
    emit("push rbp");
    emit("mov rbp, rsp");

    int32_t fsize = frame_.frame_size();
    // Ensure enough space for shadow space on any calls + frame
    // Minimum 32 bytes for shadow space even if no locals
    if (fsize < kShadowSpace) fsize = kShadowSpace;
    // Align to 16 bytes (account for pushed rbp)
    if (fsize % 16 != 0) fsize = (fsize + 15) & ~15;

    emit(fmt::format("sub rsp, {}", fsize));

    // Save parameters from registers to stack slots
    for (size_t i = 0; i < func.params.size() && i < kMaxRegArgs; ++i) {
        auto param_id = func.params[i]->id;
        if (frame_.has_slot(param_id)) {
            emit(fmt::format("mov {}, {}",
                             stack_operand(param_id),
                             reg_name(kArgRegs[i])));
        }
    }
}

void X64CodeGenerator::emit_epilogue() {
    int32_t fsize = frame_.frame_size();
    if (fsize < kShadowSpace) fsize = kShadowSpace;
    if (fsize % 16 != 0) fsize = (fsize + 15) & ~15;

    emit(fmt::format("add rsp, {}", fsize));
    emit("pop rbp");
    emit("ret");
}

void X64CodeGenerator::scan_allocas(const ir::Function& func) {
    // First allocate slots for all parameters
    for (const auto& param : func.params) {
        frame_.allocate(param->id, 8); // All params are 8 bytes (qword)
    }

    // Then scan all allocas in all blocks
    for (const auto& block : func.blocks) {
        for (const auto& inst : block->instructions) {
            if (inst->opcode == ir::Opcode::Alloca) {
                int32_t size = type_size(inst->type);
                if (size < 8) size = 8; // Minimum 8 bytes
                frame_.allocate(inst->id, size);
            }
        }
    }
}

void X64CodeGenerator::prescan_temps(const ir::Function& func) {
    // Pre-allocate temp stack slots for every value-producing instruction
    // so the frame size is fully known before the prologue is emitted.
    for (const auto& block : func.blocks) {
        for (const auto& inst : block->instructions) {
            // Skip allocas (already handled) and non-value instructions
            if (inst->opcode == ir::Opcode::Alloca) continue;

            // Check if this instruction produces a value that needs a temp slot
            bool produces_value = true;
            switch (inst->opcode) {
                case ir::Opcode::Store:
                case ir::Opcode::Br:
                case ir::Opcode::CondBr:
                case ir::Opcode::Ret:
                case ir::Opcode::Switch:
                case ir::Opcode::ChanSend:
                case ir::Opcode::MapSet:
                case ir::Opcode::GoSpawn:
                case ir::Opcode::DeferCall:
                case ir::Opcode::Panic:
                case ir::Opcode::Println:
                    produces_value = false;
                    break;
                default:
                    break;
            }

            if (produces_value && !frame_.has_slot(inst->id)) {
                (void)get_temp_slot(inst->id);
            }

            // ConstString needs an extra slot for the length
            if (inst->opcode == ir::Opcode::ConstString) {
                uint32_t len_id = inst->id + 100000;
                if (!frame_.has_slot(len_id) && temp_slots_.find(len_id) == temp_slots_.end()) {
                    frame_.allocate(len_id, 8);
                    temp_slots_[len_id] = frame_.offset_of(len_id);
                }
            }

            // Load of string type needs extra slot for length
            if (inst->opcode == ir::Opcode::Load && is_string_type(inst->type)) {
                uint32_t len_id = inst->id + 100000;
                if (!frame_.has_slot(len_id) && temp_slots_.find(len_id) == temp_slots_.end()) {
                    frame_.allocate(len_id, 8);
                    temp_slots_[len_id] = frame_.offset_of(len_id);
                }
            }
        }
    }
}

// ============================================================================
// Block generation
// ============================================================================

void X64CodeGenerator::emit_block(const ir::BasicBlock& block, const ir::Function& func) {
    // Don't emit label for entry block if it's the first block
    bool is_entry = (&block == func.blocks.front().get());
    if (!is_entry) {
        emit_label(block_label(func, block.label));
    }

    for (const auto& inst : block.instructions) {
        emit_instruction(*inst, func);
    }
}

// ============================================================================
// Helpers
// ============================================================================

void X64CodeGenerator::emit(std::string_view line) {
    out_ += "    ";
    out_ += line;
    out_ += "\n";
}

void X64CodeGenerator::emit_label(std::string_view label) {
    out_ += label;
    out_ += ":\n";
}

void X64CodeGenerator::emit_comment(std::string_view comment) {
    out_ += "; ";
    out_ += comment;
    out_ += "\n";
}

void X64CodeGenerator::emit_blank() {
    out_ += "\n";
}

int32_t X64CodeGenerator::get_temp_slot(uint32_t value_id) {
    auto it = temp_slots_.find(value_id);
    if (it != temp_slots_.end()) return it->second;

    int32_t offset = frame_.allocate(value_id, 8);
    temp_slots_[value_id] = offset;
    return offset;
}

void X64CodeGenerator::load_value_to_rax(const ir::Value* val) {
    load_value_to_reg(val, X64Reg::RAX);
}

void X64CodeGenerator::load_value_to_reg(const ir::Value* val, X64Reg reg) {
    if (!val) return;

    auto r = reg_name(reg);

    // Check if it's a constant instruction that we can inline
    auto* inst = dynamic_cast<const ir::Instruction*>(val);
    if (inst) {
        switch (inst->opcode) {
            case ir::Opcode::ConstInt:
                emit(fmt::format("mov {}, {}", r, inst->imm_int));
                return;
            case ir::Opcode::ConstBool:
                emit(fmt::format("mov {}, {}", r, inst->imm_int ? 1 : 0));
                return;
            default:
                break;
        }
    }

    // Check if it's a function (for call targets)
    auto* func = dynamic_cast<const ir::Function*>(val);
    if (func) {
        emit(fmt::format("lea {}, [{}]", r, masm_name(func->name)));
        return;
    }

    // Otherwise load from stack
    if (frame_.has_slot(val->id)) {
        emit(fmt::format("mov {}, QWORD PTR [rbp{}]", r, frame_.offset_of(val->id)));
    } else if (temp_slots_.count(val->id)) {
        emit(fmt::format("mov {}, QWORD PTR [rbp{}]", r, temp_slots_[val->id]));
    }
}

std::string X64CodeGenerator::stack_operand(uint32_t value_id) const {
    if (frame_.has_slot(value_id)) {
        return fmt::format("QWORD PTR [rbp{}]", frame_.offset_of(value_id));
    }
    auto it = temp_slots_.find(value_id);
    if (it != temp_slots_.end()) {
        return fmt::format("QWORD PTR [rbp{}]", it->second);
    }
    return fmt::format("QWORD PTR [rbp-???{}]", value_id);
}

std::string X64CodeGenerator::masm_name(std::string_view ir_name) {
    std::string result(ir_name);
    for (auto& c : result) {
        if (c == '.') c = '$';
    }
    return result;
}

std::string X64CodeGenerator::block_label(const ir::Function& func,
                                           std::string_view block_name) {
    return fmt::format("{}${}", masm_name(func.name), masm_name(block_name));
}

int32_t X64CodeGenerator::type_size(const ir::IRType* type) {
    if (!type) return 8;
    switch (type->kind) {
        case ir::IRTypeKind::Void: return 0;
        case ir::IRTypeKind::I1:   return 1;
        case ir::IRTypeKind::I8:   return 1;
        case ir::IRTypeKind::I16:  return 2;
        case ir::IRTypeKind::I32:  return 4;
        case ir::IRTypeKind::I64:  return 8;
        case ir::IRTypeKind::F32:  return 4;
        case ir::IRTypeKind::F64:  return 8;
        case ir::IRTypeKind::Ptr:  return 8;
        case ir::IRTypeKind::Struct: {
            int32_t total = 0;
            for (auto* f : type->fields) {
                total += type_size(f);
                // Align each field to its natural alignment (simplified: 8-byte)
                if (total % 8 != 0) total = (total + 7) & ~7;
            }
            return total > 0 ? total : 8;
        }
        case ir::IRTypeKind::Array:
            return type_size(type->element) * static_cast<int32_t>(type->count);
        case ir::IRTypeKind::Func:
            return 8; // Function pointer
    }
    return 8;
}

bool X64CodeGenerator::is_string_type(const ir::IRType* type) {
    if (!type || type->kind != ir::IRTypeKind::Struct) return false;
    return type->fields.size() == 2 &&
           type->fields[0]->kind == ir::IRTypeKind::Ptr &&
           type->fields[1]->kind == ir::IRTypeKind::I64;
}

} // namespace codegen
} // namespace golangc
